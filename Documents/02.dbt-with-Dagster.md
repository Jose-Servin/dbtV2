# Orchestrating dbt with Dagster

## Installing Dagster

To install Dagster, we `pip` installed 2 new packages.

```text
dagster-dbt==0.22.0
dagster-webserver==1.6.0
```

We must make sure to install these packages in our activated virtual environment and then update our `requirements.txt` file.

## Connecting Dagster and dbt

1. Set up the Dagster project scaffold - make sure to run this at the parent level of our `dbtlearnV2` project; so in `DBTV2`.

```terminal
dagster-dbt project scaffold --project-name dbt_dagster_project --dbt-project-dir=dbtlearnV2
```

![Dagster Scaffold](/images/dagster-scaffold.png)

We can see what our `dbt_dagster_project` consists of by running `tree` at the `dbt_dagster_project` level.

```terminal
.
├── __pycache__
│   └── __init__.cpython-310.pyc
├── dbt_dagster_project
│   ├── __init__.py
│   ├── assets.py
│   ├── constants.py
│   ├── definitions.py
│   └── schedules.py
├── pyproject.toml
└── setup.py
```

To get our dagster webserver up and running, we uncomment the `/dbt_dagster_project/dbt_dagster_project/schedules.py` file and run

```terminal
cd dbt_dagster_project
DAGSTER_DBT_PARSE_PROJECT_ON_LOAD=1 dagster dev
```

![Dagster Webserver](/images/dagster-webserver.png)

## Understanding our Dagster Scaffold Build

The reason we see the nested `../dbt_dagster_project/dbt_dagster_project` is because we can also set up packages, in their own directory; but for now, we only see our newly created dagster project.

* `setup.py` will allow us to build a python package from this `dbt_dagster_project`; this type of file is standard in the world of Python for building custom packages.

### File 1

`../dbt_dagster_project/dbt_dagster_project/definitions.py`

This file will contain DAG definitions as well as schedules for executing these DAGS. We integrate Dagster + dbt by using this `CLIResource` - `from dagster_dbt import DbtCliResource`. This links our Dagster and dbt project. This file is also how we glue together all of the other Dagster files we will examine; so at the end, everything ties together here in `definitions.py`. Specifically, the `Definitions` object is what Dagster will take a look at when it starts up.


```python
# definitions.py
defs = Definitions(
    assets=[dbtlearnV2_dbt_assets],
    schedules=schedules,
    resources={
        "dbt": DbtCliResource(project_dir=os.fspath(dbt_project_dir)),
    },
)
```

### File 2

`../dbt_dagster_project/dbt_dagster_project/constants.py`

Now, we'll take a look at each command starting with `resources` and the `constants.py` file.

```python
resources={
        "dbt": DbtCliResource(project_dir=os.fspath(dbt_project_dir)),
    },
```

This is saying, "Set up a dbt plugin using my dbt project located here"

We can see how our dbt project location is defined by viewing `constants.py` which essentially creates a pointer and resolves all file paths to our dbt project.

In `constants.py` we also see that "if `DAGSTER_DBT_PARSE_PROJECT_ON_LOAD` is enabled" Dagster will `parse` our project; re-read models, tests, macos and create what is known as a `manifest.json` file. If this command is not enabled we simply read the existing `manifest.json` file.

```python
# constants.py
if os.getenv("DAGSTER_DBT_PARSE_PROJECT_ON_LOAD"):
    dbt_manifest_path = (
        dbt.cli(
            ["--quiet", "parse"],
            target_path=Path("target"),
        )
        .wait()
        .target_path.joinpath("manifest.json")
    )
else:
    dbt_manifest_path = dbt_project_dir.joinpath("target", "manifest.json")
```

### What is this manifest.json file?

In our dbt project, we can view the manifest.json file by going to `../dbtlearnV2/target/manifest.json`. The `manifest.json` file in a dbt project serves as a metadata file that captures information about the dbt artifacts and their relationships. We can also think of this file as the core descriptor that captures everything we've defined in our dbt project.

### File 3

`../dbt_dagster_project/dbt_dagster_project/assets.py`

Remember that at a high level, `assets` in Dagster are very similar to `models` in dbt.

Here we see `dbt_assets` being defined, which essentially say "using my manifest.json file, execute `dbt build` to bring our dbt project into Dagster." We can think of these as jobs that Dagster will perform on our dbt project.

```python
@dbt_assets(manifest=dbt_manifest_path)
def dbtlearnV2_dbt_assets(context: AssetExecutionContext, dbt: DbtCliResource):
    yield from dbt.cli(["build"], context=context).stream()
```

### File 4

`../dbt_dagster_project/dbt_dagster_project/schedules.py`

This file is a bit self-explanatory - here we see our `assets` scheduled.

```python
schedules = [
    build_schedule_from_dbt_selection(
        [dbtlearnV2_dbt_assets],
        job_name="materialize_dbt_models",
        cron_schedule="0 0 * * *",
        dbt_select="fqn:*",
    ),
]
```

See how the asset we defined is now being scheduled.

Note

* `dbt_select="fqn:*"` stand for "fully qualified name" and is saying "materialize all of our defined dbt models".

## Manage, Orchestrate and Debug your dbt Project with Dagster
